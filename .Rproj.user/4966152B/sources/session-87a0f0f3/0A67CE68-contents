#' Universal spatial join between vector and raster data
#'
#' @description
#' Universal function for spatial joins that works with ANY vector geometry
#' (points, lines, polygons) and ANY raster data type (NDVI, soil, climate, etc.).
#' Automatically handles different input formats and coordinate systems.
#'
#' @param vector_data Vector data (sf object, data.frame with coordinates, or file path)
#' @param raster_data Single raster, list of rasters, or directory path
#' @param coord_cols Column names for coordinates (if vector_data is data.frame)
#' @param method Extraction method: "simple", "buffer", "bilinear", "nearest"
#' @param buffer_size Buffer size for buffer method (in map units)
#' @param summary_function Function for buffer extraction: "mean", "median", "max", "min", "sum"
#' @param crs_code CRS code for coordinate columns (default: 4326)
#' @param variable_names Optional names for raster variables
#' @param geometry_type Type of vector geometry: "points", "lines", "polygons", "auto"
#'
#' @return sf object with extracted raster values
#'
#' @examples
#' \dontrun{
#' # Join ANY vector data with ANY raster data
#' result <- spatial_join_universal(
#'   vector_data = "study_sites.csv",
#'   raster_data = "ndvi_time_series/",
#'   method = "buffer",
#'   buffer_size = 1000
#' )
#'
#' # Works with soil data
#' soil_result <- spatial_join_universal(
#'   vector_data = farm_fields,
#'   raster_data = "soil_properties/",
#'   method = "simple"
#' )
#'
#' # Works with climate data
#' climate_result <- spatial_join_universal(
#'   vector_data = weather_stations,
#'   raster_data = c("temp.tif", "precip.tif"),
#'   method = "bilinear"
#' )
#' }
#'
#' @export
spatial_join_universal <- function(vector_data, raster_data, coord_cols = c("lon", "lat"),
                                   method = "simple", buffer_size = 1000,
                                   summary_function = "mean", crs_code = 4326,
                                   variable_names = NULL, geometry_type = "auto") {

  message("Starting universal spatial join...")
  message("Works with ANY raster data: NDVI, soil, climate, elevation, water quality, etc.")

  # Load and process raster data (handles multiple formats)
  raster_list <- load_raster_data(raster_data)

  # Create variable names if not provided
  if (is.null(variable_names)) {
    if (is.character(raster_data) && length(raster_data) == 1 && dir.exists(raster_data)) {
      # Directory provided - use filenames
      files <- list.files(raster_data, pattern = "\\.(tif|tiff)$", full.names = FALSE)
      variable_names <- tools::file_path_sans_ext(files)
    } else if (is.character(raster_data)) {
      # File paths provided
      variable_names <- tools::file_path_sans_ext(basename(raster_data))
    } else {
      # Generic names
      variable_names <- paste0("variable_", seq_along(raster_list))
    }
  }

  # Ensure variable names match number of rasters
  if (length(variable_names) != length(raster_list)) {
    variable_names <- paste0("variable_", seq_along(raster_list))
  }

  # Clean variable names (make valid R names)
  variable_names <- make.names(gsub("[^A-Za-z0-9_]", "_", variable_names))

  # Process vector data (handles multiple formats)
  vector_sf <- process_vector_data(vector_data, coord_cols, crs_code)

  # Determine geometry type
  if (geometry_type == "auto") {
    geom_type <- as.character(sf::st_geometry_type(vector_sf, by_geometry = FALSE))
    geometry_type <- tolower(gsub("MULTI", "", geom_type))
  }

  message(sprintf("Processing %s geometry with %d raster layer(s)", geometry_type, length(raster_list)))

  # Perform extraction for each raster
  for (i in seq_along(raster_list)) {
    raster_layer <- raster_list[[i]]
    var_name <- variable_names[i]

    message(sprintf("Extracting values for: %s", var_name))

    # Ensure CRS compatibility
    if (!sf::st_crs(vector_sf) == sf::st_crs(raster_layer)) {
      message("Reprojecting vector data to match raster CRS...")
      vector_sf <- sf::st_transform(vector_sf, crs = sf::st_crs(raster_layer))
    }

    # Extract values based on method and geometry type
    extracted_values <- perform_extraction(vector_sf, raster_layer, method,
                                           buffer_size, summary_function, geometry_type)

    # Add extracted values to vector data
    vector_sf[[var_name]] <- extracted_values
  }

  message("Universal spatial join completed successfully!")
  return(vector_sf)
}

#' Process vector data from various input formats
#'
#' @description
#' Internal function to process vector data from different input formats.
#'
#' @param vector_data Vector data input
#' @param coord_cols Coordinate column names
#' @param crs_code CRS code
#'
#' @return sf object
#'
#' @keywords internal
process_vector_data <- function(vector_data, coord_cols = c("lon", "lat"), crs_code = 4326) {

  if (is.character(vector_data)) {
    # File path provided
    if (grepl("\\.(csv|txt)$", vector_data)) {
      # CSV/text file
      df <- read.csv(vector_data)

      # Try to detect coordinate columns automatically
      if (!all(coord_cols %in% names(df))) {
        # Look for common coordinate column names
        lon_candidates <- c("lon", "longitude", "lng", "x", "X", "LongitudeMeasure")
        lat_candidates <- c("lat", "latitude", "y", "Y", "LatitudeMeasure")

        lon_col <- intersect(lon_candidates, names(df))[1]
        lat_col <- intersect(lat_candidates, names(df))[1]

        if (!is.na(lon_col) && !is.na(lat_col)) {
          coord_cols <- c(lon_col, lat_col)
          message(sprintf("Auto-detected coordinate columns: %s, %s", lon_col, lat_col))
        } else {
          stop("Could not detect coordinate columns. Please specify coord_cols parameter.")
        }
      }

      vector_sf <- sf::st_as_sf(df, coords = coord_cols, crs = crs_code)

    } else {
      # Spatial file (shapefile, geojson, etc.)
      vector_sf <- sf::st_read(vector_data)
    }

  } else if (is.data.frame(vector_data) && !inherits(vector_data, "sf")) {
    # Data frame with coordinates
    vector_sf <- sf::st_as_sf(vector_data, coords = coord_cols, crs = crs_code)

  } else if (inherits(vector_data, "sf")) {
    # Already an sf object
    vector_sf <- vector_data

  } else {
    stop("Unsupported vector_data format. Must be file path, data.frame, or sf object.")
  }

  return(vector_sf)
}

#' Perform extraction based on method and geometry type
#'
#' @description
#' Internal function to perform raster value extraction.
#'
#' @param vector_sf sf object
#' @param raster_layer SpatRaster
#' @param method Extraction method
#' @param buffer_size Buffer size
#' @param summary_function Summary function
#' @param geometry_type Geometry type
#'
#' @return Vector of extracted values
#'
#' @keywords internal
perform_extraction <- function(vector_sf, raster_layer, method, buffer_size,
                               summary_function, geometry_type) {

  # Convert summary_function string to actual function
  summary_func <- switch(summary_function,
                         "mean" = function(x) mean(x, na.rm = TRUE),
                         "median" = function(x) median(x, na.rm = TRUE),
                         "max" = function(x) max(x, na.rm = TRUE),
                         "min" = function(x) min(x, na.rm = TRUE),
                         "sum" = function(x) sum(x, na.rm = TRUE),
                         "sd" = function(x) sd(x, na.rm = TRUE),
                         "mode" = function(x) {
                           ux <- unique(x[!is.na(x)])
                           if (length(ux) == 0) return(NA)
                           ux[which.max(tabulate(match(x, ux)))]
                         },
                         function(x) mean(x, na.rm = TRUE)  # Default to mean
  )

  extracted_values <- switch(method,

                             "simple" = {
                               # Simple point extraction (works for all geometry types)
                               if (geometry_type == "polygon") {
                                 # For polygons, extract all values within and summarize
                                 terra::extract(raster_layer, vector_sf, fun = summary_func, df = TRUE)[, 2]
                               } else {
                                 # For points/lines, extract at exact locations
                                 terra::extract(raster_layer, vector_sf)[, 2]
                               }
                             },

                             "buffer" = {
                               # Buffer-based extraction (works for all geometry types)
                               buffered_geom <- sf::st_buffer(vector_sf, dist = buffer_size)
                               terra::extract(raster_layer, buffered_geom, fun = summary_func, df = TRUE)[, 2]
                             },

                             "bilinear" = {
                               # Bilinear interpolation (mainly for points)
                               terra::extract(raster_layer, vector_sf, method = "bilinear")[, 2]
                             },

                             "nearest" = {
                               # Nearest neighbor (works for all)
                               terra::extract(raster_layer, vector_sf, method = "simple")[, 2]
                             },

                             stop(paste("Unsupported extraction method:", method))
  )

  return(extracted_values)
}

#' Advanced multi-variable spatial integration
#'
#' @description
#' Integrate multiple raster datasets with vector data in a single operation.
#' Perfect for comprehensive analysis combining NDVI, soil, climate, and other data.
#'
#' @param vector_data Vector data (points, lines, or polygons)
#' @param raster_datasets Named list of raster datasets
#' @param analysis_functions Named list of analysis functions to apply
#' @param region_boundary Optional region boundary for clipping
#' @param output_format Output format: "sf", "dataframe", "both"
#'
#' @return Integrated spatial data with all variables
#'
#' @examples
#' \dontrun{
#' # Integrate multiple datasets at once
#' integrated_data <- integrate_multiple_datasets(
#'   vector_data = study_sites,
#'   raster_datasets = list(
#'     ndvi = "ndvi_time_series/",
#'     soil_nitrogen = "soil_nitrogen/",
#'     elevation = "dem.tif",
#'     temperature = "temperature_data/"
#'   )
#' )
#' }
#'
#' @export
integrate_multiple_datasets <- function(vector_data, raster_datasets,
                                        analysis_functions = NULL,
                                        region_boundary = NULL,
                                        output_format = "sf") {

  message("Starting multi-variable spatial integration...")
  message("Integrating multiple data types: NDVI, soil, climate, topography, etc.")

  # Load vector data
  vector_sf <- process_vector_data(vector_data)

  # Apply region boundary if specified
  if (!is.null(region_boundary)) {
    boundary <- get_region_boundary(region_boundary)
    vector_sf <- sf::st_filter(vector_sf, boundary)
  }

  # Default analysis functions
  if (is.null(analysis_functions)) {
    analysis_functions <- list(
      mean = function(x) mean(x, na.rm = TRUE),
      median = function(x) median(x, na.rm = TRUE),
      sd = function(x) sd(x, na.rm = TRUE),
      min = function(x) min(x, na.rm = TRUE),
      max = function(x) max(x, na.rm = TRUE)
    )
  }

  # Process each dataset
  for (dataset_name in names(raster_datasets)) {
    dataset_path <- raster_datasets[[dataset_name]]

    message(sprintf("Processing dataset: %s", dataset_name))

    # Perform spatial join
    temp_result <- spatial_join_universal(
      vector_data = vector_sf,
      raster_data = dataset_path,
      method = "buffer",
      variable_names = paste0(dataset_name, "_raw")
    )

    # Apply analysis functions
    for (func_name in names(analysis_functions)) {
      func <- analysis_functions[[func_name]]
      raw_col <- paste0(dataset_name, "_raw")
      new_col <- paste0(dataset_name, "_", func_name)

      if (raw_col %in% names(temp_result)) {
        vector_sf[[new_col]] <- func(temp_result[[raw_col]])
      }
    }
  }

  # Return in requested format
  result <- switch(output_format,
                   "sf" = vector_sf,
                   "dataframe" = sf::st_drop_geometry(vector_sf),
                   "both" = list(sf = vector_sf, dataframe = sf::st_drop_geometry(vector_sf)),
                   vector_sf
  )

  message("Multi-variable integration completed!")
  return(result)
}
