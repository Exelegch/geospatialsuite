#' Get comprehensive CDL crop codes
#'
#' @description
#' Get USDA Cropland Data Layer (CDL) codes for specific crops or crop categories.
#' Supports all major crops and predefined categories.
#'
#' @param crop_type Crop type or category name. Options include:
#'   \itemize{
#'     \item Individual crops: "corn", "soybeans", "wheat", etc.
#'     \item Categories: "grains", "oilseeds", "fruits", "vegetables", etc.
#'     \item "all" for all available codes
#'   }
#'
#' @return Vector of CDL codes
#'
#' @examples
#' \dontrun{
#' # Get corn code
#' corn_codes <- get_comprehensive_cdl_codes("corn")
#'
#' # Get all grain crop codes
#' grain_codes <- get_comprehensive_cdl_codes("grains")
#'
#' # Get all available codes
#' all_codes <- get_comprehensive_cdl_codes("all")
#'
#' # See available crop types
#' get_comprehensive_cdl_codes("help")
#' }
#'
#' @export
get_comprehensive_cdl_codes <- function(crop_type = "all") {

  # Comprehensive CDL codes database
  cdl_database <- list(
    # Major Field Crops
    corn = 1, cotton = 2, rice = 3, sorghum = 4, soybeans = 5,
    sunflower = 6, peanuts = 7, tobacco = 8, sweet_corn = 12,
    pop_or_orn_corn = 13, mint = 14, barley = 21, durum_wheat = 22,
    spring_wheat = 23, winter_wheat = 24, other_small_grains = 25,
    dbl_crop_winwht_soybeans = 26, rye = 27, oats = 28, millet = 29,
    speltz = 30, canola = 31, flaxseed = 32, safflower = 33,
    rape_seed = 34, mustard = 35, alfalfa = 36, other_hay_non_alfalfa = 37,
    camelina = 38, buckwheat = 39, sugarbeets = 41, dry_beans = 42,
    potatoes = 43, other_crops = 44, sugarcane = 45, sweet_potatoes = 46,
    misc_vegs_fruits = 47, watermelons = 48, onions = 49, cucumbers = 50,
    chick_peas = 51, lentils = 52, peas = 53, tomatoes = 54,
    caneberries = 55, hops = 56, herbs = 57, clover_wildflowers = 58,
    sod_grass_seed = 59, switchgrass = 60, fallow_idle_cropland = 61,

    # Fruits and Nuts
    cherries = 66, peaches = 67, apples = 68, grapes = 69,
    christmas_trees = 70, other_tree_crops = 71, citrus = 72,
    pecans = 73, almonds = 74, walnuts = 75, pears = 76,

    # Vegetables (200+ series)
    carrots = 206, asparagus = 207, garlic = 208, cantaloupes = 209,
    prunes = 210, olives = 211, oranges = 212, honeydew_melons = 213,
    broccoli = 214, avocados = 215, peppers = 216, pomegranates = 217,
    nectarines = 218, greens = 219, plums = 220, strawberries = 221,
    squash = 222, apricots = 223, vetch = 224, dbl_crop_oats_corn = 225,
    lettuce = 227,

    # Pasture and Grassland
    pasture_grass = 176, grassland_pasture = 181,

    # Forest
    deciduous_forest = 141, evergreen_forest = 142, mixed_forest = 143,

    # Water and Wetlands
    water = 111, perennial_ice_snow = 112, herbaceous_wetlands = 195,
    woody_wetlands = 190,

    # Developed Areas
    developed_open_space = 121, developed_low_intensity = 122,
    developed_med_intensity = 123, developed_high_intensity = 124,

    # Other Land Cover
    barren = 131, shrubland = 152, grassland_herbaceous = 171
  )

  # Predefined categories
  crop_categories <- list(
    grains = c(1, 4, 21, 22, 23, 24, 25, 27, 28, 29, 30),
    oilseeds = c(5, 6, 31, 32, 33, 34, 35),
    fruits = c(66, 67, 68, 69, 72, 73, 74, 75, 76, 210, 211, 212, 215, 217, 218, 220, 221, 223),
    vegetables = c(47, 48, 49, 50, 54, 206, 207, 208, 209, 213, 214, 216, 219, 222, 227),
    legumes = c(42, 51, 52, 53),
    forage = c(36, 37, 58, 176, 181),
    specialty = c(8, 14, 45, 56, 57, 70),
    food_crops = c(1, 3, 5, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 47, 66, 67, 68, 69),
    feed_crops = c(36, 37, 58, 176),
    industrial_crops = c(2, 8, 31, 32, 33, 38),
    all_crops = c(1:8, 12:14, 21:61, 66:76, 204:227)
  )

  if (crop_type == "all") {
    return(sort(unique(unlist(cdl_database))))
  } else if (crop_type == "help") {
    cat("Available crop types and categories:\n")
    cat("\nIndividual crops:\n")
    print(names(cdl_database))
    cat("\nCrop categories:\n")
    print(names(crop_categories))
    return(invisible(NULL))
  } else if (crop_type %in% names(crop_categories)) {
    return(crop_categories[[crop_type]])
  } else if (crop_type %in% names(cdl_database)) {
    return(cdl_database[[crop_type]])
  } else {
    # Try partial matching
    matches <- names(cdl_database)[grepl(crop_type, names(cdl_database), ignore.case = TRUE)]
    if (length(matches) > 0) {
      return(cdl_database[[matches[1]]])
    } else {
      message("Available crop types:")
      message("Individual crops: ", paste(names(cdl_database), collapse = ", "))
      message("Categories: ", paste(names(crop_categories), collapse = ", "))
      stop(paste("Crop type not found:", crop_type))
    }
  }
}

#' Create crop mask from CDL data
#'
#' @description
#' Create binary or classified crop mask from USDA CDL data for specified crops.
#'
#' @param cdl_data CDL raster data (file path or SpatRaster)
#' @param crop_codes Vector of CDL codes or crop names
#' @param region_boundary Optional region boundary for clipping
#' @param mask_type Type of mask: "binary" (1/0) or "preserve" (keep original codes)
#'
#' @return SpatRaster with crop mask
#'
#' @examples
#' \dontrun{
#' # Create corn mask
#' corn_mask <- create_crop_mask("cdl_2023.tif", "corn", "Iowa")
#'
#' # Create grain crops mask
#' grain_mask <- create_crop_mask(cdl_raster, "grains", mask_type = "preserve")
#'
#' # Use custom codes
#' custom_mask <- create_crop_mask(cdl_data, c(1, 5, 21), "Ohio")
#' }
#'
#' @export
create_crop_mask <- function(cdl_data, crop_codes, region_boundary = NULL, mask_type = "binary") {
  # Load CDL data
  if (is.character(cdl_data)) {
    cdl_raster <- terra::rast(cdl_data)
  } else {
    cdl_raster <- cdl_data
  }

  # Get crop codes if character names provided
  if (is.character(crop_codes)) {
    if (length(crop_codes) == 1) {
      codes <- get_comprehensive_cdl_codes(crop_codes)
    } else {
      codes <- unlist(lapply(crop_codes, get_comprehensive_cdl_codes))
    }
  } else {
    codes <- crop_codes
  }

  # Apply region boundary if provided
  if (!is.null(region_boundary)) {
    boundary <- get_region_boundary(region_boundary)
    boundary_vect <- terra::vect(boundary)
    cdl_raster <- terra::crop(cdl_raster, boundary_vect)
    cdl_raster <- terra::mask(cdl_raster, boundary_vect)
  }

  # Create mask based on type
  if (mask_type == "binary") {
    mask <- cdl_raster
    mask[!(cdl_raster %in% codes)] <- 0
    mask[cdl_raster %in% codes] <- 1
    names(mask) <- "crop_mask_binary"
  } else if (mask_type == "preserve") {
    mask <- cdl_raster
    mask[!(cdl_raster %in% codes)] <- NA
    names(mask) <- "crop_mask_preserve"
  } else {
    stop("mask_type must be 'binary' or 'preserve'")
  }

  return(mask)
}

#' Analyze CDL crops dynamically
#'
#' @description
#' Perform dynamic analysis of CDL crop data including area calculations,
#' classification, and masking for any crop combination.
#'
#' @param cdl_data CDL raster data
#' @param crop_selection Crop selection (names, codes, or categories)
#' @param region_boundary Region boundary
#' @param analysis_type Type of analysis: "mask", "classify", "area"
#' @param output_folder Output directory
#' @param year Year for analysis (optional)
#'
#' @return Analysis results (depends on analysis_type)
#'
#' @examples
#' \dontrun{
#' # Analyze soybean area in Iowa
#' soybean_area <- analyze_cdl_crops_dynamic(
#'   "cdl_2023.tif", "soybeans", "Iowa", "area"
#' )
#'
#' # Create grain classification
#' grain_classes <- analyze_cdl_crops_dynamic(
#'   cdl_data, "grains", "CONUS", "classify"
#' )
#' }
#'
#' @export
analyze_cdl_crops_dynamic <- function(cdl_data, crop_selection, region_boundary = NULL,
                                      analysis_type = "classify", output_folder = NULL,
                                      year = NULL) {

  message("Starting dynamic CDL crop analysis...")

  # Load CDL data
  if (is.character(cdl_data)) {
    cdl_raster <- terra::rast(cdl_data)
  } else {
    cdl_raster <- cdl_data
  }

  # Get crop codes
  if (is.numeric(crop_selection)) {
    crop_codes <- crop_selection
    crop_name <- "custom_selection"
  } else if (is.character(crop_selection)) {
    if (length(crop_selection) == 1) {
      crop_codes <- get_comprehensive_cdl_codes(crop_selection)
      crop_name <- crop_selection
    } else {
      crop_codes <- unlist(lapply(crop_selection, get_comprehensive_cdl_codes))
      crop_name <- paste(crop_selection, collapse = "_")
    }
  } else {
    stop("crop_selection must be numeric codes or character names")
  }

  message(sprintf("Analyzing %d crop codes for %s", length(crop_codes), crop_name))

  # Apply region boundary if provided
  if (!is.null(region_boundary)) {
    boundary <- get_region_boundary(region_boundary)
    boundary_vect <- terra::vect(boundary)
    cdl_raster <- terra::crop(cdl_raster, boundary_vect)
    cdl_raster <- terra::mask(cdl_raster, boundary_vect)
  }

  # Perform analysis based on type
  result <- switch(analysis_type,
                   "mask" = {
                     crop_mask <- create_crop_mask(cdl_raster, crop_codes, mask_type = "binary")
                     names(crop_mask) <- paste0(crop_name, "_mask")
                     crop_mask
                   },

                   "classify" = {
                     binary_class <- cdl_raster
                     binary_class[cdl_raster %in% crop_codes] <- 1
                     binary_class[!(cdl_raster %in% crop_codes)] <- 0
                     names(binary_class) <- paste0(crop_name, "_binary")
                     binary_class
                   },

                   "area" = {
                     pixel_size <- prod(terra::res(cdl_raster)) / 10000  # Convert to hectares

                     crop_areas <- list()
                     for (code in crop_codes) {
                       crop_pixels <- sum(terra::values(cdl_raster) == code, na.rm = TRUE)
                       crop_areas[[as.character(code)]] <- crop_pixels * pixel_size
                     }

                     total_area <- sum(unlist(crop_areas))

                     list(
                       crop_areas_ha = crop_areas,
                       total_area_ha = total_area,
                       pixel_size_ha = pixel_size,
                       crop_codes = crop_codes
                     )
                   },

                   stop(paste("Unsupported analysis type:", analysis_type))
  )

  # Save results if output folder specified
  if (!is.null(output_folder)) {
    if (!dir.exists(output_folder)) {
      dir.create(output_folder, recursive = TRUE)
    }

    if (inherits(result, "SpatRaster")) {
      output_file <- file.path(output_folder, paste0(crop_name, "_", analysis_type, ".tif"))
      terra::writeRaster(result, output_file, overwrite = TRUE)
      message(sprintf("Results saved to: %s", output_file))
    }
  }

  message("CDL analysis completed!")
  return(result)
}
